package main

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"
)

// Key represents the "key" type of the Apple Device Management YAML.
type Key struct {
	Key       string   `yaml:"key"`
	Type      string   `yaml:"type"`
	Presence  string   `yaml:"presence,omitempty"`
	SubKeys   []Key    `yaml:"subkeys,omitempty"`
	Content   string   `yaml:"content"`
	RangeList []string `yaml:"rangelist,omitempty"`

	// used to override the name (and plist key) of the field for a dictionary type
	keyOverride string
	// whether to include the Content (aka comment) on a field comment
	includeContent bool
	// whether this comment only applies to the struct itself
	contentIsForStruct bool
	// force this Go type for the key
	forceRawType bool
	// this field, if in a struct, should be another embedded struct.
	// used with forceRawType.
	embeddedStruct bool
}

// Payload represents the "payload" section defined in the Apple
// Device Management YAML.
type Payload struct {
	RequestType string `yaml:"requesttype"`
	Content     string `yaml:"content"`
}

// Command represents an entire MDM command defined in the Apple
// Device Management YAML.
type Command struct {
	Payload      Payload `yaml:"payload"`
	PayloadKeys  []Key   `yaml:"payloadkeys"`
	ResponseKeys []Key   `yaml:"responsekeys"`
}
type jenBuilder struct {
	file *File

	noShared       bool
	noDependShared bool
	noResponses    bool
}

func newJenBuilder(pkgName string, sources []string, noShared, noDependShared, noResponse bool) *jenBuilder {
	j := &jenBuilder{
		file:           NewFile(pkgName),
		noShared:       noShared,
		noDependShared: noDependShared,
		noResponses:    noResponse,
	}
	j.file.PackageComment("Code generated by \"admgencmd\"; DO NOT EDIT.")
	if len(sources) >= 1 {
		plural := ""
		if len(sources) > 1 {
			plural = "s"
		}
		j.file.PackageComment(fmt.Sprintf("Source%s: %s", plural, strings.Join(sources, ", ")))
	}
	var options []string
	if j.noShared {
		options = append(options, "no-shared=true")
	}
	if j.noDependShared {
		options = append(options, "no-depend=true")
	}
	if j.noResponses {
		options = append(options, "no-responses=true")
	}
	if len(options) >= 1 {
		j.file.PackageComment("Options: " + strings.Join(options, ","))
	}
	return j
}

var commandUUIDKey = Key{
	Key:      "CommandUUID",
	Type:     "<string>",
	Presence: "required",
}

func NewRequestTypeKey(name string) Key {
	if name == "" {
		name = "the MDM command name"
	}
	return Key{
		Key:       "RequestType",
		Type:      "<string>",
		Presence:  "required",
		RangeList: []string{name},
	}
}

var networkTetherKey = Key{
	Key:      "RequestRequiresNetworkTether",
	Type:     "<boolean>",
	Presence: "optional",
}

var statusKey = Key{
	Key:       "Status",
	Type:      "<string>",
	Presence:  "required",
	RangeList: []string{"Acknowledged", "Error", "CommandFormatError", "Idle", "NotNow"},
}

var notConsKey = Key{
	Key:      "NotOnConsole",
	Type:     "<boolean>",
	Presence: "required", // marked as required in Apple docs site but no schema data to confirm this
}

var errorChainKey = Key{
	Key:          "ErrorChain",
	Type:         "ErrorChain",
	Presence:     "optional",
	forceRawType: true,
}

func insertErrorChain(j *jenBuilder) {
	j.handleKey(errorChainItem, "")

	j.file.Comment("ErrorChain represents any errors that occured on the client executing an MDM command.")
	j.file.Type().Id("ErrorChain").Index().Id("ErrorChainItem")

	j.file.Comment("Error adapts a standard Go error for ErrorChain.")
	j.file.Func().Params(
		Id("ec").Op("*").Id("ErrorChain"),
	).Id("Error").Params().String().Block(
		If(Len(Op("*").Id("ec")).Op("<").Lit(1)).Block(
			Return(Lit("no items in error chain")),
		),
		Var().Id("s").String(),
		For(
			Id("i").Op(":=").Len(Op("*").Id("ec")).Op("-").Lit(1),
			Id("i").Op(">=").Lit(0),
			Id("i").Op("--"),
		).Block(
			If(Id("s").Op("!=").Lit("")).Block(
				Id("s").Op("+=").Lit(": "),
			),
			Comment("not intentionally trying to be US-centric here. however,"),
			Comment("the searchability of error messages is often more successful"),
			Comment("with the US english versions"),
			Id("errStr").Op(":=").Parens(Op("*").Id("ec")).Index(Id("i")).Dot("USEnglishDescription"),
			If(Id("errStr").Op("==").Lit("")).Block(
				Id("errStr").Op("=").Parens(Op("*").Id("ec")).Index(Id("i")).Dot("LocalizedDescription"),
			),
			Id("s").Op("+=").Qual("fmt", "Sprintf").Params(
				Lit("%s (%s, %d)"),
				Id("errStr"),
				Parens(Op("*").Id("ec")).Index(Id("i")).Dot("ErrorDomain"),
				Parens(Op("*").Id("ec")).Index(Id("i")).Dot("ErrorCode"),
			),
		),
		Return(Id("s")),
	)
}

var enrollmentKey = Key{
	Key:            "Enrollment",
	Type:           "Enrollment",
	Presence:       "required",
	forceRawType:   true,
	embeddedStruct: true,
}

var errorChainItem = Key{
	Key:  "ErrorChainItem",
	Type: "<dictionary>",
	SubKeys: []Key{
		{Key: "ErrorCode", Type: "<integer>", Presence: "required"},
		{Key: "ErrorDomain", Type: "<string>", Presence: "required"},
		{Key: "LocalizedDescription", Type: "<string>", Presence: "required"},
		{Key: "USEnglishDescription", Type: "<string>", Presence: "required"},
	},
	Content:            "ErrorChainItem represents an error that occured on the client executing an MDM command.",
	includeContent:     true,
	contentIsForStruct: true,
}

var enrollment = Key{
	Key:  "Enrollment",
	Type: "<dictionary>",
	SubKeys: []Key{
		{Key: "UDID", Type: "<string>", Presence: "optional"},
		{Key: "UserID", Type: "<string>", Presence: "optional"},
		{Key: "UserShortName", Type: "<string>", Presence: "optional"},
		{Key: "UserLongName", Type: "<string>", Presence: "optional"},
		{Key: "EnrollmentID", Type: "<string>", Presence: "optional"},
		{Key: "EnrollmentUserID", Type: "<string>", Presence: "optional"},
	},
	Content:            "Enrollment represents the various enrollment-related data sent with responses.",
	includeContent:     true,
	contentIsForStruct: true,
}

func (j *jenBuilder) createShared() {
	payload := Key{
		Key:         "GenericCommandPayload",
		keyOverride: "Command",
		Type:        "<dictionary>",
		Presence:    "required",

		Content:            "GenericCommandPayload is the \"inner\" generic payload for Apple MDM commands.",
		includeContent:     true,
		contentIsForStruct: true,

		SubKeys: []Key{NewRequestTypeKey(""), networkTetherKey},
	}
	cmd := Key{
		Key:      "GenericCommand",
		Type:     "<dictionary>",
		Presence: "required",

		Content:            "GenericCommand represents a generic command.",
		includeContent:     true,
		contentIsForStruct: true,

		SubKeys: []Key{
			commandUUIDKey,
			payload,
		},
	}
	j.handleKey(cmd, "")

	// create the interface for the generic command
	j.file.Comment("GenericCommanders can extract a GenericCommand.")
	j.file.Type().Id("GenericCommander").Interface(
		Id("GenericCommand").Params().Op("*").Id("GenericCommand"),
	)

	// create the interface for getting the generic response
	j.file.Comment("GenericResponsers can extract a GenericResponse.")
	j.file.Type().Id("GenericResponser").Interface(
		Id("GetGenericResponse").Params().Op("*").Id("GenericResponse"),
	)

	// create a helper function to instantiate our generic command
	j.file.Comment("New" + cmd.Key + " creates a new generic Apple MDM command.")
	j.file.Func().Id("New" + cmd.Key).Params(Id("requestType").String()).Op("*").Id(cmd.Key).Block(
		Return(Op("&").Id(cmd.Key).Values(Dict{
			Id("Command"): Id(payload.Key).Values(Dict{
				Id("RequestType"): Id("requestType"),
			}),
		})),
	)

	j.file.Var().Id("newCommandFuncs").Map(String()).Func().Params(String()).Interface().Op("=").Make(Map(String()).Func().Params(String()).Interface())
	if !j.noResponses {
		j.file.Var().Id("newResponseFuncs").Map(String()).Func().Params().Interface().Op("=").Make(Map(String()).Func().Params().Interface())
	}

	// create a helper function to instantiate a command
	j.file.Comment("NewCommand creates a new command from requestType.")
	j.file.Func().Id("NewCommand").Params(Id("requestType").String(), Id("uuid").String()).Interface().Block(
		List(Id("newCmdFn"), Id("ok")).Op(":=").Id("newCommandFuncs").Index(Id("requestType")),
		If(Id("!ok").Op("||").Id("newCmdFn").Op("==").Nil()).Block(Return(Nil())),
		Return(Id("newCmdFn").Call(Id("uuid"))),
	)

	j.file.Comment("ValidRequestType checks that we are able to create a new command from requestType.")
	j.file.Func().Id("ValidRequestType").Params(Id("requestType").String()).Bool().Block(
		List(Id("_"), Id("ok")).Op(":=").Id("newCommandFuncs").Index(Id("requestType")),
		Return(Id("ok")),
	)

	if !j.noResponses {
		// create a helper function to instantiate a command
		j.file.Comment("NewResponse creates a new command response from requestType.")
		j.file.Func().Id("NewResponse").Params(Id("requestType").String()).Interface().Block(
			List(Id("newRespFn"), Id("ok")).Op(":=").Id("newResponseFuncs").Index(Id("requestType")),
			If(Id("!ok").Op("||").Id("newRespFn").Op("==").Nil()).Block(Return(Nil())),
			Return(Id("newRespFn").Call()),
		)

		insertErrorChain(j)

		j.handleKey(enrollment, "")

		response := Key{
			Key:  "GenericResponse",
			Type: "<dictionary>",
			SubKeys: []Key{
				commandUUIDKey,
				statusKey,
				notConsKey,
				errorChainKey,
				enrollmentKey,
			},
			Content:            "GenericResponse represents the common MDM command response fields.",
			includeContent:     true,
			contentIsForStruct: true,
		}

		j.handleKey(response, "")

		insertValidate(response.Key, j)
	}
}

func (j *jenBuilder) walkCommand(keys []Key, name string) {
	// create a "const" string of the RequestType for the command
	j.file.Const().Id(name + "RequestType").Op("=").Lit(name)

	var payload Key
	if len(keys) >= 1 || j.noDependShared {
		// the command "payload" is the actual command data, one level up
		// from the command.
		payload = Key{
			Key:         name + "Payload",
			Type:        "<dictionary>",
			SubKeys:     keys,
			keyOverride: "Command",
			Presence:    "required",

			Content:            name + "Payload is the \"inner\" command-specific payload for the \"" + name + "\" Apple MDM command.",
			includeContent:     true,
			contentIsForStruct: true,
		}

		// insert the RequestType and 'NetworkTether fields into the keys.
		// these aren't specified in the schema.
		payload.SubKeys = append(payload.SubKeys,
			NewRequestTypeKey(name),
			networkTetherKey,
		)
	} else {
		payload = Key{
			Key:          "GenericCommandPayload",
			Type:         "GenericCommandPayload",
			Presence:     "required",
			keyOverride:  "Command",
			forceRawType: true,
		}
	}

	// finally put together the actual base-level MDM command struct
	cmd := Key{
		Key:     name + "Command",
		Type:    "<dictionary>",
		SubKeys: []Key{payload, commandUUIDKey},

		Content:            name + "Command is the top-level structure for the \"" + name + "\" Apple MDM command.",
		includeContent:     true,
		contentIsForStruct: true,
	}

	// Go (hah) convert it to code now
	j.handleKey(cmd, "")

	if !j.noDependShared {
		// create a helper method to return a copy of a generic command
		j.file.Comment("GenericCommand creates a new generic command using the values of c.")
		j.file.Func().Params(
			Id("c").Op("*").Id(name+"Command"),
		).Id("GenericCommand").Params().Op("*").Id("GenericCommand").Block(
			If(Id("c").Op("==").Nil()).Block(
				Return(Nil()),
			),
			Id("cmd").Op(":=").Id("NewGenericCommand").Call(Id("c.Command.RequestType")),
			Id("cmd.CommandUUID").Op("=").Id("c.CommandUUID"),
			Id("cmd.Command.RequestRequiresNetworkTether").Op("=").Id("c.Command.RequestRequiresNetworkTether"),
			Return(Id("cmd")),
		)
	}

	// create a helper function to instantiate our command with the correct RequestType
	j.file.Comment("New" + cmd.Key + " creates a new \"" + name + "\" Apple MDM command.")
	j.file.Func().Id("New" + cmd.Key).Params(Id("uuid").String()).Op("*").Id(cmd.Key).Block(
		Return(Op("&").Id(cmd.Key).Values(Dict{
			Id("Command"): Id(payload.Key).Values(Dict{
				Id("RequestType"): Id(name + "RequestType"),
			}),
			Id("CommandUUID"): Id("uuid"),
		})),
	)

	// create a helper function for instantiating command structs
	if !j.noDependShared {
		j.file.Line()
		j.file.Func().Id("init").Params().Block(
			Comment("associate our Request Type to a function for creating a command of that type"),
			Id("newCommandFuncs").Index(Id(name+"RequestType")).Op("=").Func().Params(Id("uuid").String()).Interface().Block(
				Return(Id("New"+cmd.Key).Call(Id("uuid"))),
			),
		)
	}
}

func insertValidate(name string, j *jenBuilder) {
	j.file.Comment("Validate checks for any command response errors.")
	j.file.Func().Params(
		Id("r").Op("*").Id(name),
	).Id("Validate").Params().Error().Block(
		If(Id("r").Dot("ErrorChain").Op("!=").Nil().Op("||").Parens(Id("r").Dot("Status").Op("!=").Lit("Acknowledged").Op("&&").Id("r").Dot("Status").Op("!=").Lit("Idle").Op("&&").Id("r").Dot("Status").Op("!=").Lit("NotNow"))).Block(
			Return(Qual("fmt", "Errorf").Params(
				Lit("MDM error for status %s: %w"),
				Id("r").Dot("Status"),
				Id("r").Dot("ErrorChain")),
			),
		),
		Return(Nil()),
	)
}

func (j *jenBuilder) walkResponse(keys []Key, name string) {
	response := Key{
		Key:     name + "Response",
		Type:    "<dictionary>",
		SubKeys: keys,

		Content:            name + "Response is the command result report (response) for the \"" + name + "\" Apple MDM command.",
		includeContent:     true,
		contentIsForStruct: true,
	}
	if j.noDependShared {
		insertErrorChain(j)
		j.handleKey(enrollment, "")

		response.SubKeys = append(response.SubKeys,
			commandUUIDKey,
			statusKey,
			notConsKey,
			errorChainKey,
			enrollmentKey,
		)
	} else {
		response.SubKeys = append(
			response.SubKeys,
			Key{
				Key:            "GenericResponse",
				Type:           "GenericResponse",
				Presence:       "required",
				forceRawType:   true,
				embeddedStruct: true,
			},
		)
	}
	j.handleKey(response, "")

	insertValidate(response.Key, j)

	if !j.noDependShared {
		// create a helper method to return a copy of a generic command
		j.file.Comment("GetGenericResponse creates a new generic command response using the values of r.")
		j.file.Func().Params(
			Id("r").Op("*").Id(response.Key),
		).Id("GetGenericResponse").Params().Op("*").Id("GenericResponse").Block(
			// Id("cmd").Op(":=").Id("NewGenericCommand").Call(Id("c.Command.RequestType")),
			// Id("cmd.CommandUUID").Op("=").Id("c.CommandUUID"),
			// Id("cmd.Command.RequestRequiresNetworkTether").Op("=").Id("c.Command.RequestRequiresNetworkTether"),
			// Return(Id("cmd")),
			Return(Op("&").Id("r.GenericResponse")),
		)
	}

	// create a helper function for instantiating response structs
	if !j.noDependShared {
		j.file.Line()
		j.file.Func().Id("init").Params().Block(
			Comment("associate our Request Type to a function for creating a response of that type"),
			Id("newResponseFuncs").Index(Id(name+"RequestType")).Op("=").Func().Params().Interface().Block(
				Return(New(Id(response.Key))),
			),
		)
	}
}

func (j *jenBuilder) handleKey(key Key, parentType string) (s *Statement, comment string) {
	switch key.Type {
	case "<string>":
		s = String()
	case "<integer>":
		s = Int()
	case "<boolean>":
		s = Bool()
	case "<real>":
		s = Float64()
	case "<data>":
		s = Index().Byte()
	case "<date>":
		s = Qual("time", "Time")
	case "<dictionary>":
		if len(key.SubKeys) == 1 {
			k := key.SubKeys[0]
			switch k.Type {
			case "<dictionary>":
				_, comment := j.handleDict(k)
				if comment != "" {
					comment += ", "
				}
				comment += "assuming string map for single dictionary subkey"
				return Map(String()).Op("*").Id(k.Key), comment
			case "<any>":
				return Interface(), "<any> type as single dictionary subkey"
			}
		}
		s, comment = j.handleDict(key)
	case "<array>":
		s, comment = j.handleArray(key)
		s = Index().Add(s)
	default:
		if key.forceRawType {
			s = Id(key.Type)
		} else {
			s = Interface()
			comment = "unknown type: " + key.Type
		}
	}
	if len(key.RangeList) >= 1 {
		if comment != "" {
			comment += ", "
		}
		begin := "supported value"
		if len(key.RangeList) > 1 {
			begin += "s"
		}
		comment += begin + ": " + strings.Join(key.RangeList, ", ")
	}
	if parentType != "<array>" && s != nil && key.Presence != "required" {
		s = Op("*").Add(s)
	}
	return
}

func (j *jenBuilder) handleArray(key Key) (s *Statement, comment string) {
	keys := key.SubKeys
	if len(keys) < 1 {
		return Interface(), "missing array keys in schema"
	}
	keyType := keys[0].Type
	for _, key := range keys[1:] {
		if key.Type != keyType {
			// return an interface{} as we seem to have mismatched types within our array
			return Interface(), "mismatched array types in schema"
		}
	}

	if keyType == "<dictionary>" && len(keys) > 1 {
		var items []string
		for _, k := range keys {
			items = append(items, k.Key)
			k.contentIsForStruct = true
			k.includeContent = true
			// note we're overwriting the comment (Content) in the yaml
			k.Content = key.Key + " array type"

			j.handleKey(k, "")
		}
		return Interface(), "array of dictionary keys, instantiate and populate items, keys: " + strings.Join(items, ", ")
	}

	s, comment = j.handleKey(keys[0], key.Type)
	if len(keys) == 1 && keys[0].Type != "<dictionary>" && len(keys[0].SubKeys) > 0 {
		// if our single key is a scalar type and we have subkeys
		// then the subkeys describe actual array values
		if comment != "" {
			comment += ", "
		}
		comment += fmt.Sprintf("%d array value(s) defined in schema", len(keys[0].SubKeys))
	}
	return
}

func (j *jenBuilder) handleDict(key Key) (s *Statement, comment string) {
	var fields []Code
	for _, k := range key.SubKeys {
		s, comment := j.handleKey(k, key.Type)
		if s == nil {
			panic("handleKey should not have returned nil")
		}
		fieldName := normalizeFieldName(k.Key)
		if k.keyOverride != "" {
			fieldName = k.keyOverride
		}
		var jenField *Statement
		if !k.embeddedStruct {
			jenField = Id(fieldName).Add(s)
		} else {
			jenField = s
		}
		var tag string
		if k.keyOverride == "" && (k.Key != fieldName) {
			tag = k.Key
		}
		if k.Presence == "optional" {
			tag += ",omitempty"
		}
		if tag != "" {
			jenField.Tag(map[string]string{"plist": tag})
		}
		if k.includeContent && !k.contentIsForStruct {
			if comment != "" {
				comment += ", "
			}
			comment += k.Content
		}
		if comment != "" {
			jenField.Comment(comment)
		}
		fields = append(fields, jenField)
	}
	if key.includeContent && key.contentIsForStruct {
		j.file.Comment(key.Content)
	}
	// create a new struct in the file with fields
	j.file.Type().Id(key.Key).Struct(fields...)
	return Id(key.Key), ""
}

func strip(s string) string {
	var result strings.Builder
	for i := 0; i < len(s); i++ {
		b := s[i]
		if ('a' <= b && b <= 'z') ||
			('A' <= b && b <= 'Z') ||
			('0' <= b && b <= '9') {
			result.WriteByte(b)
		}
	}
	return result.String()
}

func normalizeFieldName(s string) string {
	s = strings.ToUpper(s[0:1]) + s[1:]
	return strip(s)
}
