package main

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"
)

type jenBuilder struct {
	file *File

	noDependShared bool
	noResponses    bool
}

func newJenBuilder(pkgName string, sources []string) *jenBuilder {
	j := &jenBuilder{file: NewFile(pkgName)}
	j.file.PackageComment("Code generated by \"admgencmd\"; DO NOT EDIT.")
	if len(sources) >= 1 {
		plural := ""
		if len(sources) > 1 {
			plural = "s"
		}
		j.file.PackageComment(fmt.Sprintf("Source%s: %s", plural, strings.Join(sources, ", ")))
	}
	return j
}

var commandUUIDKey = Key{
	Key:      "CommandUUID",
	Type:     "<string>",
	Presence: "required",
}

var requestTypeKey = Key{
	Key:            "RequestType",
	Type:           "<string>",
	Presence:       "required",
	Content:        "must be set to MDM command name",
	includeContent: true,
}

var networkTetherKey = Key{
	Key:      "RequestRequiresNetworkTether",
	Type:     "<boolean>",
	Presence: "optional",
}

func (j *jenBuilder) createShared() {
	payload := Key{
		Key:         "GenericCommandPayload",
		keyOverride: "Command",
		Type:        "<dictionary>",
		Presence:    "required",

		Content:            "GenericCommandPayload is the \"inner\" generic payload for Apple MDM commands.",
		includeContent:     true,
		contentIsForStruct: true,

		SubKeys: []Key{requestTypeKey, networkTetherKey},
	}
	cmd := Key{
		Key:      "GenericCommand",
		Type:     "<dictionary>",
		Presence: "required",

		Content:            "GenericCommand represents a generic command.",
		includeContent:     true,
		contentIsForStruct: true,

		SubKeys: []Key{
			commandUUIDKey,
			payload,
		},
	}
	j.handleKey(cmd, "")

	// create the interface for the generic command
	j.file.Comment("GenericCommanders can extract a GenericCommand.")
	j.file.Type().Id("GenericCommander").Interface(
		Id("GenericCommand").Params().Op("*").Id("GenericCommand"),
	)

	// create a helper function to instantiate our our generic command
	j.file.Comment("New" + cmd.Key + " creates a new generic Apple MDM command.")
	j.file.Func().Id("New" + cmd.Key).Params(Id("requestType").String()).Op("*").Id(cmd.Key).Block(
		Return(Op("&").Id(cmd.Key).Values(Dict{
			Id("Command"): Id(payload.Key).Values(Dict{
				Id("RequestType"): Id("requestType"),
			}),
		})),
	)

	j.file.Var().Id("newCommandFuncs").Map(String()).Func().Params().Interface().Op("=").Make(Map(String()).Func().Params().Interface())
	if !j.noResponses {
		j.file.Var().Id("newResponseFuncs").Map(String()).Func().Params().Interface().Op("=").Make(Map(String()).Func().Params().Interface())
	}

	// create a helper function to instantiate a command
	j.file.Comment("NewCommand creates a new command from requestType.")
	j.file.Func().Id("NewCommand").Params(Id("requestType").String()).Interface().Block(
		List(Id("newCmdFn"), Id("ok")).Op(":=").Id("newCommandFuncs").Index(Id("requestType")),
		If(Id("!ok").Op("||").Id("newCmdFn").Op("==").Nil()).Block(Return(Nil())),
		Return(Id("newCmdFn").Call()),
	)

	if !j.noResponses {
		// create a helper function to instantiate a command
		j.file.Comment("NewResponse creates a new command response from requestType.")
		j.file.Func().Id("NewResponse").Params(Id("requestType").String()).Interface().Block(
			List(Id("newRespFn"), Id("ok")).Op(":=").Id("newResponseFuncs").Index(Id("requestType")),
			If(Id("!ok").Op("||").Id("newRespFn").Op("==").Nil()).Block(Return(Nil())),
			Return(Id("newRespFn").Call()),
		)
	}
}

func (j *jenBuilder) walkCommand(keys []Key, name string) {
	// create a "const" string of the RequestType for the command
	j.file.Const().Id(name + "RequestType").Op("=").Lit(name)

	rtk := requestTypeKey
	rtk.Content = "must be set to \"" + name + "\""

	// insert the RequestType and 'NetworkTether fields into the keys.
	// these aren't specified in the schema.
	keys = append(keys, rtk, networkTetherKey)

	// the command "payload" is the actual command data, one level up
	// from the command.
	payload := Key{
		Key:         name + "Payload",
		Type:        "<dictionary>",
		SubKeys:     keys,
		keyOverride: "Command",
		Presence:    "required",

		Content:            name + "Payload is the \"inner\" command-specific payload for the \"" + name + "\" Apple MDM command.",
		includeContent:     true,
		contentIsForStruct: true,
	}

	// finally put together the actual base-level MDM command struct
	cmd := Key{
		Key:     name + "Command",
		Type:    "<dictionary>",
		SubKeys: []Key{payload, commandUUIDKey},

		Content:            name + "Command is the top-level structure for the \"" + name + "\" Apple MDM command.",
		includeContent:     true,
		contentIsForStruct: true,
	}

	// Go (hah) convert it to code now
	j.handleKey(cmd, "")

	if !j.noDependShared {
		// create a helper method to return a copy of a generic command
		j.file.Comment("GenericCommand creates a new generic command using the values of c")
		j.file.Func().Params(
			Id("c").Op("*").Id(name+"Command"),
		).Id("GenericCommand").Params().Op("*").Id("GenericCommand").Block(
			Id("cmd").Op(":=").Id("NewGenericCommand").Call(Id("c.Command.RequestType")),
			Id("cmd.CommandUUID").Op("=").Id("c.CommandUUID"),
			Id("cmd.Command.RequestRequiresNetworkTether").Op("=").Id("c.Command.RequestRequiresNetworkTether"),
			Return(Id("cmd")),
		)
	}

	// create a helper function to instantiate our command with the correct RequestType
	j.file.Comment("New" + cmd.Key + " creates a new \"" + name + "\" Apple MDM command.")
	j.file.Func().Id("New" + cmd.Key).Params().Op("*").Id(cmd.Key).Block(
		Return(Op("&").Id(cmd.Key).Values(Dict{
			Id("Command"): Id(payload.Key).Values(Dict{
				Id("RequestType"): Id(name + "RequestType"),
			}),
		})),
	)

	// create a helper function for instantiating command structs
	if !j.noDependShared {
		j.file.Line()
		j.file.Func().Id("init").Params().Block(
			Comment("associate our Request Type to a function for creating a command of that type"),
			Id("newCommandFuncs").Index(Id(name+"RequestType")).Op("=").Func().Params().Interface().Block(
				Return(Id("New"+cmd.Key).Call()),
			),
		)
	}
}

func (j *jenBuilder) walkResponse(keys []Key, name string) {
	statusKey := Key{
		Key:      "Status",
		Type:     "<string>",
		Presence: "required",
	}
	keys = append(keys,
		commandUUIDKey,
		statusKey,
		// TODO:
		//
		// EnrollmentID
		// EnrollmentUserID
		// ErrorChain
		// NotOnConsole
		// UDID
		// UserID
		// UserLongName
		// UserShortName
	)
	response := Key{
		Key:     name + "Response",
		SubKeys: keys,
		Type:    "<dictionary>",
	}
	j.handleKey(response, "")

	// create a helper function for instantiating response structs
	if !j.noDependShared {
		j.file.Line()
		j.file.Func().Id("init").Params().Block(
			Comment("associate our Request Type to a function for creating a response of that type"),
			Id("newResponseFuncs").Index(Id(name+"RequestType")).Op("=").Func().Params().Interface().Block(
				Return(New(Id(response.Key))),
			),
		)
	}
}

func (j *jenBuilder) handleKey(key Key, parentType string) (s *Statement, comment string) {
	switch key.Type {
	case "<string>":
		s = String()
	case "<integer>":
		s = Int()
	case "<boolean>":
		s = Bool()
	case "<real>":
		s = Float64()
	case "<data>":
		s = Index().Byte()
	case "<date>":
		s = Qual("time", "Time")
	case "<dictionary>":
		s, comment = j.handleDict(key)
	case "<array>":
		s, comment = j.handleArray(key)
		s = Index().Add(s)
	default:
		s = Interface()
		comment = "unknown type: " + key.Type
	}
	if parentType != "<array>" && s != nil && key.Presence != "required" {
		s = Op("*").Add(s)
	}
	return
}

func (j *jenBuilder) handleArray(key Key) (s *Statement, comment string) {
	keys := key.SubKeys
	if len(keys) < 1 {
		return Interface(), "missing array keys in schema"
	}
	keyType := keys[0].Type
	for _, key := range keys[1:] {
		if key.Type != keyType {
			// return an interface{} as we seem to have mismatched types within our array
			return Interface(), "mismatched array types in schema"
		}
	}

	s, comment = j.handleKey(keys[0], key.Type)
	if len(keys) == 1 && keys[0].Type != "<dictionary>" && len(keys[0].SubKeys) > 0 {
		// if our single key is a scalar type and we have subkeys
		// then the the subkeys describe actual array values
		if comment != "" {
			comment += ", "
		}
		comment += fmt.Sprintf("%d array values defined in schema", len(keys[0].SubKeys))
	}
	return
}

func (j *jenBuilder) handleDict(key Key) (s *Statement, comment string) {
	var fields []Code
	for _, k := range key.SubKeys {
		s, comment := j.handleKey(k, key.Type)
		if s == nil {
			panic("handleKey should not have returned nil")
		}
		fieldName := normalizeFieldName(k.Key)
		if k.keyOverride != "" {
			fieldName = k.keyOverride
		}
		jenField := Id(fieldName).Add(s)
		var tag string
		if k.keyOverride == "" && (k.Key != fieldName) {
			tag = k.Key
		}
		if k.Presence == "optional" {
			tag += ",omitempty"
		}
		if tag != "" {
			jenField.Tag(map[string]string{"plist": tag})
		}
		if k.includeContent && !k.contentIsForStruct {
			if comment != "" {
				comment += ", "
			}
			comment += k.Content
		}
		if comment != "" {
			jenField.Comment(comment)
		}
		fields = append(fields, jenField)
	}
	if key.includeContent && key.contentIsForStruct {
		j.file.Comment(key.Content)
	}
	// create a new struct in the file with fields
	j.file.Type().Id(key.Key).Struct(fields...)
	return Id(key.Key), ""
}

func strip(s string) string {
	var result strings.Builder
	for i := 0; i < len(s); i++ {
		b := s[i]
		if ('a' <= b && b <= 'z') ||
			('A' <= b && b <= 'Z') ||
			('0' <= b && b <= '9') {
			result.WriteByte(b)
		}
	}
	return result.String()
}

func normalizeFieldName(s string) string {
	s = strings.ToUpper(s[0:1]) + s[1:]
	return strip(s)
}
