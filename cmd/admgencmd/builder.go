package main

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"
)

type jenBuilder struct {
	file *File
	ptr  bool

	noLegacyStructComment bool
	tagChanged            bool // only use a tag if the name has changed
}

func newJenBuilder(pkgName string) *jenBuilder {
	j := &jenBuilder{file: NewFile(pkgName)}
	j.file.PackageComment("Code generated by \"admgencmd\"; DO NOT EDIT.")
	return j
}

func (j *jenBuilder) walkCommand(keys []Key, name string) {
	// j.file.Const().Id(name + "RequestType").Op("=").Lit(name)
	keys = append(keys,
		Key{Key: "RequestType", Type: "<string>"},
		// Key{Key: "RequestRequiresNetworkTether", Type: "<boolean>", Presence: "optional"},
	)
	payload := Key{
		Key:         name + "Payload",
		Type:        "<dictionary>",
		SubKeys:     keys,
		keyOverride: "Command",
	}
	cmd := Key{
		Key:     name + "Command",
		Type:    "<dictionary>",
		SubKeys: []Key{payload, {Key: "CommandUUID", Type: "<string>"}},
	}
	j.handleKey(cmd)
	// j.file.Comment("New" + cmd.Key + " creates ...")
	// j.file.Func().Id("New" + cmd.Key).Params().Op("*").Id(cmd.Key).Block(
	// 	Return(Op("&").Id(cmd.Key).Values()),
	// )
}

func (j *jenBuilder) walkResponse(keys []Key, name string) {
	keys = append(keys,
		Key{Key: "CommandUUID", Type: "<string>"},
		Key{Key: "Status", Type: "<string>"},
		// TODO:
		// EnrollmentID
		// EnrollmentUserID
		// ErrorChain
		// NotOnConsole
		// UDID
		// UserID
		// UserLongName
		// UserShortName
	)
	j.handleDict(keys, name+"Response")
}

func (j *jenBuilder) runPrint(keys []Key, name string) {
	j.file.Const().Id(name + "RequestType").Op("=").Lit(name)
	j.handleDict(keys, name)
	j.file.Comment("New" + name + " creates ...")
	j.file.Func().Id("New" + name).Params().Op("*").Id(name).Block(
		Return(Op("&").Id(name).Values()),
	)
	fmt.Printf("%#v", j.file)
}

func (j *jenBuilder) handleKey(key Key) (*Statement, string) {
	ptr := func(sin *Statement) (sout *Statement) {
		if j.ptr {
			return Op("*").Add(sin)
		}
		return sin
	}
	switch key.Type {
	case "<string>":
		return ptr(String()), ""
	case "<integer>":
		return ptr(Int()), ""
	case "<boolean>":
		return ptr(Bool()), ""
	case "<real>":
		return ptr(Float64()), ""
	case "<data>":
		return ptr(Index().Byte()), ""
	// case "<date>":
	// 	return ptr(Qual("time", "Time")), ""
	case "<dictionary>":
		j.handleDict(key.SubKeys, key.Key)
		return ptr(Id(key.Key)), ""
	case "<array>":
		goType, comment := j.handleArray(key.SubKeys)
		return Index().Add(goType), comment
	default:
		return nil, ""
	}
}

func (j *jenBuilder) handleArray(keys []Key) (*Statement, string) {
	if len(keys) < 1 {
		return Interface(), "missing array keys in schema"
	}
	keyType := keys[0].Type
	for _, key := range keys[1:] {
		if key.Type != keyType {
			// return an interface{} as we seem to have mismatched types within our array
			return Interface(), "mismatched array types in schema"
		}
	}

	goType, comment := j.handleKey(keys[0])
	if len(keys) == 1 && keys[0].Type != "<dictionary>" && len(keys[0].SubKeys) > 0 {
		// if our single key is a scalar type and we have subkeys
		// then the the subkeys describe actual array values
		if comment != "" {
			comment += ", "
		}
		comment += fmt.Sprintf("%d array values defined in schema", len(keys[0].SubKeys))
	}
	return goType, comment
}

func (j *jenBuilder) handleDict(keys []Key, name string) {
	var fields []Code
	for _, key := range keys {
		goFieldName := normalizeFieldName(key.Key)
		schemaFieldName := key.Key
		if key.keyOverride != "" {
			// fieldName = key.keyOverride
			// goField
			goFieldName = key.keyOverride
			schemaFieldName = key.keyOverride
		}
		jenField := Id(goFieldName)
		goType, comment := j.handleKey(key)
		if goType == nil {
			goType = Interface()
			if comment != "" {
				comment += ", "
			}
			comment = "unknown type: " + key.Type
		}
		jenField = jenField.Add(goType)
		tag := schemaFieldName
		if j.tagChanged && goFieldName == schemaFieldName {
			tag = ""
		}
		if key.Presence == "optional" {
			tag += ",omitempty"
		}
		if tag != "" {
			jenField.Tag(map[string]string{"plist": tag})
		}
		if comment != "" {
			jenField.Comment(comment)
		}
		fields = append(fields, jenField)
	}
	if !j.noLegacyStructComment {
		j.file.Comment(name)
	}
	j.file.Type().Id(name).Struct(fields...)
}

func strip(s string) string {
	var result strings.Builder
	for i := 0; i < len(s); i++ {
		b := s[i]
		if ('a' <= b && b <= 'z') ||
			('A' <= b && b <= 'Z') ||
			('0' <= b && b <= '9') {
			result.WriteByte(b)
		}
	}
	return result.String()
}

func normalizeFieldName(s string) string {
	s = strings.ToUpper(s[0:1]) + s[1:]
	return strip(s)
}
